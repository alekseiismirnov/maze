Maze
=====

Create a Sinatra application with CRUD functionality where users can traverse a maze. 

* Each "room" of the maze should have a description and one or more ways to move to another room. 
* For instance, if the room is a dead end, then a user should be able to return to the previous room.
* There could be a winning condition if the user successfully traverses the maze.

+ Start by building a maze with a few hard-coded rooms. 
+ Use a whiteboard to visualize your maze before building it. 

- Then add CRUD functionality so users can add more rooms to the maze.
    + create room
    + retrive saved room properties
    + update
    + delete

>>> New rooms are created from the existing one. All maze
>>> has a tree-like structure. 
>>> We could delete any room, remove doors to it from the neigbours
>>> and forget about them.
 
+ CRUD frontend for rooms. 

+ Add items with type and descriptions to the rooms. Item's type 
  displayed in room's description.

+ After player look on it, he'll se item's description.  
  This will involve nested routing - for instance, an object belongs 
  to a room. For a user to look at it, they might have to navigate 
  to /rooms/7/items/3

+ Allow a user to pick up items from various rooms of the maze.
  + And drop it from inventory to the room.
  + It will involve the **inventory section**.
- Some of these items (such as a key or a flashlight) 
  might be necessary to successfully escape.
  - All rooms have an additional property, indicating
    if it is an "exit" room.
  - It could be triggered by the particular item 
    in the inventory.
  - Room with the exit should have a correspondent 
    description.
  
- Add levers to some of the rooms. 
- A user will only be able to pass through the door to the exit 
if the levers are in a certain position.

... Continue to build out your maze in any way you like!
